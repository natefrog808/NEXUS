<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS89: Glitch Nexus Unleashed with HESMS Agents</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%238A2BE2'/><path d='M50 10L90 90H10L50 10Z' fill='%23FF4500'/><circle cx='50' cy='50' r='20' fill='%2300CED1'/></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #8A2BE2;
            --primary-dark: #6A1BA2;
            --primary-glow: rgba(138, 43, 226, 0.5);
            --secondary: #FF4500;
            --secondary-dark: #BF3500;
            --secondary-glow: rgba(255, 69, 0, 0.5);
            --tertiary: #00CED1;
            --tertiary-dark: #00989A;
            --tertiary-glow: rgba(0, 206, 209, 0.5);
            --quaternary: #FFD700;
            --quaternary-dark: #B8860B;
            --quaternary-glow: rgba(255, 215, 0, 0.5);
            --background: #0A0A1A;
            --text: #E6E6FA;
            --panel: #16162A;
            --panel-dark: #101024;
            --border: #2A2A5A;
            --highlight: #FFD700;
            --shadow: rgba(0, 0, 0, 0.5);
            --success: #00FF7F;
            --danger: #FF1493;
            --warning: #FFA500;
            --info: #1E90FF;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { overflow: hidden; height: 100%; width: 100%; }
        body {
            font-family: 'Roboto Mono', monospace;
            background-color: var(--background);
            color: var(--text);
            position: relative;
            cursor: crosshair;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: linear-gradient(90deg, transparent 97%, var(--border) 97%), linear-gradient(0deg, transparent 97%, var(--border) 97%);
            background-size: 40px 40px;
            opacity: 0.2;
            z-index: 0;
            animation: gridPulse 10s infinite ease-in-out;
        }

        @keyframes gridPulse {
            0%, 100% { background-size: 40px 40px; opacity: 0.2; }
            50% { background-size: 42px 42px; opacity: 0.25; }
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background: linear-gradient(to bottom, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            z-index: 999;
            pointer-events: none;
            opacity: 0.15;
            mix-blend-mode: overlay;
        }

        .noise {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 250 250' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            pointer-events: none;
            opacity: 0.06;
            z-index: 998;
            mix-blend-mode: overlay;
        }

        header {
            position: absolute;
            top: 0;
            width: 100%;
            padding: 1.5rem;
            text-align: center;
            background: linear-gradient(to bottom, rgba(10, 10, 26, 0.8), transparent);
            z-index: 10;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 4.5rem;
            text-transform: uppercase;
            background: linear-gradient(to right, var(--primary), var(--tertiary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px var(--primary), 0 0 25px var(--secondary);
            animation: flickerText 2s infinite;
            margin-bottom: 0.25rem;
            letter-spacing: 0.15em;
            transform: perspective(500px) rotateX(10deg);
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--highlight);
            text-shadow: 0 0 10px var(--highlight);
            margin-top: 0.25rem;
            letter-spacing: 0.2em;
        }

        #glitchCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .overlay {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(138, 43, 226, 0.2) 0%, transparent 70%);
            animation: pulseGlow 8s ease-in-out infinite;
            pointer-events: none;
            z-index: 2;
        }

        .control-panel-toggle {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 11;
            width: 3rem;
            height: 3rem;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px var(--shadow);
        }

        .control-panel-toggle:hover { box-shadow: 0 0 15px var(--primary-glow); }
        .control-panel-toggle span {
            display: block;
            width: 1.5rem;
            height: 2px;
            background: var(--text);
            position: relative;
            transition: all 0.3s ease;
        }

        .control-panel-toggle span:before,
        .control-panel-toggle span:after {
            content: '';
            position: absolute;
            width: 1.5rem;
            height: 2px;
            background: var(--text);
            transition: all 0.3s ease;
        }

        .control-panel-toggle span:before { top: -8px; }
        .control-panel-toggle span:after { top: 8px; }
        .control-panel-toggle.active span { background: transparent; }
        .control-panel-toggle.active span:before { transform: rotate(45deg); top: 0; }
        .control-panel-toggle.active span:after { transform: rotate(-45deg); top: 0; }

        .glitch-panel {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 400px;
            background: var(--panel);
            border-left: 1px solid var(--border);
            padding: 1rem;
            z-index: 10;
            transform: translateX(100%);
            transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: -5px 0 20px var(--shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .glitch-panel.active { transform: translateX(0); }
        .glitch-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .glitch-panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.25rem;
            color: var(--tertiary);
            text-shadow: 0 0 8px var(--tertiary);
        }

        .system-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            color: var(--highlight);
        }

        .panel-tabs {
            display: flex;
            gap: 0.25rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            overflow-x: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--panel-dark);
        }

        .panel-tabs::-webkit-scrollbar { height: 5px; }
        .panel-tabs::-webkit-scrollbar-track { background: var(--panel-dark); }
        .panel-tabs::-webkit-scrollbar-thumb { background-color: var(--border); border-radius: 6px; }

        .panel-tab {
            padding: 0.4rem 0.8rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            background: var(--panel-dark);
            color: var(--text);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .panel-tab:hover { background: var(--border); }
        .panel-tab.active {
            background: var(--primary-dark);
            border-color: var(--primary);
            color: white;
            box-shadow: 0 0 8px var(--primary);
        }

        .panel-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
            margin-bottom: 0.5rem;
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--panel-dark);
        }

        .panel-content::-webkit-scrollbar { width: 5px; }
        .panel-content::-webkit-scrollbar-track { background: var(--panel-dark); }
        .panel-content::-webkit-scrollbar-thumb { background-color: var(--border); border-radius: 6px; }
        .panel-content.active { display: block; }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .tool-button {
            position: relative;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 0.4rem;
            background: var(--panel-dark);
            color: var(--text);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .tool-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .tool-button:hover::before { transform: translateX(100%); }
        .tool-button .icon { font-size: 1.8rem; margin-bottom: 0.5rem; display: block; }
        .tool-button.rift { border-color: var(--secondary); }
        .tool-button.rift:hover { background: var(--secondary-dark); box-shadow: 0 0 15px var(--secondary-glow); }
        .tool-button.eruption { border-color: var(--quaternary); }
        .tool-button.eruption:hover { background: var(--quaternary-dark); box-shadow: 0 0 15px var(--quaternary-glow); color: var(--background); }
        .tool-button.nexus { border-color: var(--tertiary); }
        .tool-button.nexus:hover { background: var(--tertiary-dark); box-shadow: 0 0 15px var(--tertiary-glow); }
        .tool-button.pulse { border-color: var(--primary); }
        .tool-button.pulse:hover { background: var(--primary-dark); box-shadow: 0 0 15px var(--primary-glow); }

        .advanced-tools {
            display: flex;
            justify-content: space-between;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .advanced-tool {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.4rem;
            background: var(--panel-dark);
            color: var(--text);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.75rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .advanced-tool .icon { font-size: 1.2rem; margin-bottom: 0.25rem; }
        .advanced-tool:hover { background: var(--border); }
        .advanced-tool.reset { border-color: var(--danger); }
        .advanced-tool.reset:hover { background: var(--danger); box-shadow: 0 0 15px rgba(255, 20, 147, 0.5); }
        .advanced-tool.auto { border-color: var(--success); }
        .advanced-tool.auto:hover { background: var(--success); color: var(--background); box-shadow: 0 0 15px rgba(0, 255, 127, 0.5); }
        .advanced-tool.connect { border-color: var(--info); }
        .advanced-tool.connect:hover { background: var(--info); box-shadow: 0 0 15px rgba(30, 144, 255, 0.5); }
        .advanced-tool.attract { border-color: var(--warning); }
        .advanced-tool.attract:hover { background: var(--warning); color: var(--background); box-shadow: 0 0 15px rgba(255, 165, 0, 0.5); }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            position: relative;
            background: var(--panel-dark);
            border: 1px solid var(--border);
            border-radius: 0.4rem;
            padding: 0.75rem;
            text-align: center;
            overflow: hidden;
        }

        .stat-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--tertiary);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 1s ease;
        }

        .stat-card:hover::after { transform: scaleX(1); }
        .stat-value { font-size: 1.75rem; font-weight: bold; margin-bottom: 0.25rem; text-shadow: 0 0 10px currentColor; }
        .stat-value.rift { color: var(--secondary); }
        .stat-value.eruption { color: var(--quaternary); }
        .stat-value.nexus { color: var(--tertiary); }
        .stat-value.pulse { color: var(--primary); }
        .stat-value.total { color: var(--text); }
        .stat-value.intensity { color: var(--success); }
        .stat-label { font-size: 0.75rem; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.05em; }

        .log-container {
            background: var(--panel-dark);
            border: 1px solid var(--border);
            border-radius: 0.4rem;
            height: 300px;
            overflow-y: auto;
            font-size: 0.75rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--panel-dark);
        }

        .log-container::-webkit-scrollbar { width: 5px; }
        .log-container::-webkit-scrollbar-track { background: var(--panel-dark); }
        .log-container::-webkit-scrollbar-thumb { background-color: var(--border); border-radius: 6px; }
        .log-entry { padding: 0.25rem 0; border-bottom: 1px solid rgba(42, 42, 90, 0.5); display: flex; flex-wrap: wrap; }
        .log-time { color: var(--tertiary); margin-right: 0.5rem; font-weight: bold; white-space: nowrap; }
        .log-info { color: var(--info); }
        .log-warning { color: var(--warning); }
        .log-danger { color: var(--danger); }
        .log-success { color: var(--success); }
        .log-rift { color: var(--secondary); }
        .log-eruption { color: var(--quaternary); }
        .log-nexus { color: var(--tertiary); }
        .log-pulse { color: var(--primary); }

        .agent-info { margin-top: 0.5rem; font-size: 0.75rem; color: var(--highlight); text-shadow: 0 0 5px var(--highlight); }

        .quick-actions {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            z-index: 10;
        }

        .quick-action {
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            background: var(--panel);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px var(--shadow);
            font-size: 1.5rem;
        }

        .quick-action:hover { transform: translateY(-5px); }
        .quick-rift { color: var(--secondary); border-color: var(--secondary); }
        .quick-rift:hover { background: var(--secondary-dark); box-shadow: 0 0 15px var(--secondary-glow); }
        .quick-eruption { color: var(--quaternary); border-color: var(--quaternary); }
        .quick-eruption:hover { background: var(--quaternary-dark); box-shadow: 0 0 15px var(--quaternary-glow); }
        .quick-nexus { color: var(--tertiary); border-color: var(--tertiary); }
        .quick-nexus:hover { background: var(--tertiary-dark); box-shadow: 0 0 15px var(--tertiary-glow); }
        .quick-pulse { color: var(--primary); border-color: var(--primary); }
        .quick-pulse:hover { background: var(--primary-dark); box-shadow: 0 0 15px var(--primary-glow); }
        .quick-auto { color: var(--success); border-color: var(--success); }
        .quick-auto:hover { background: var(--success); color: var(--background); box-shadow: 0 0 15px rgba(0, 255, 127, 0.5); }
        .active-tool { background-color: var(--panel-dark); box-shadow: 0 0 15px var(--primary-glow); }

        @keyframes flickerText {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.95; text-shadow: 0 0 15px var(--primary), 0 0 25px var(--secondary), 0 0 5px var(--tertiary); }
        }

        @keyframes pulseGlow {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(1.05); }
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.5rem; }
            .subtitle { font-size: 0.9rem; }
            .glitch-panel { width: 100%; }
            .tools-grid { grid-template-columns: 1fr 1fr; }
            .quick-actions { bottom: 0.5rem; }
            .quick-action { width: 3rem; height: 3rem; font-size: 1.2rem; }
        }
    </style>
</head>
<body>
    <header>
        <h1 class="glitch-text" data-text="NEXUS89">NEXUS89</h1>
        <p class="subtitle">Glitch Nexus Unleashed with HESMS Agents</p>
    </header>

    <canvas id="glitchCanvas"></canvas>
    <div class="overlay"></div>
    <div class="scanlines"></div>
    <div class="noise"></div>

    <div class="control-panel-toggle" id="controlToggle"><span></span></div>

    <div class="glitch-panel" id="controlPanel">
        <div class="glitch-panel-header">
            <div class="glitch-panel-title">Control Nexus</div>
            <div class="system-time" id="systemTime">00:00:00</div>
        </div>
        
        <div class="panel-tabs">
            <div class="panel-tab active" data-panel="controls">Controls</div>
            <div class="panel-tab" data-panel="statistics">Statistics</div>
            <div class="panel-tab" data-panel="logs">System Log</div>
            <div class="panel-tab" data-panel="agents">Agents</div>
        </div>
        
        <div class="panel-content active" id="controls-panel">
            <div class="tools-grid">
                <div class="tool-button rift" id="spawnRift"><span class="icon">âš¡</span>Reality Rift</div>
                <div class="tool-button eruption" id="spawnEruption"><span class="icon">ðŸŒ‹</span>Dream Eruption</div>
                <div class="tool-button nexus" id="spawnNexus"><span class="icon">ðŸ”„</span>Sync Nexus</div>
                <div class="tool-button pulse" id="spawnPulse"><span class="icon">ðŸ’«</span>Consciousness Pulse</div>
            </div>
            <div class="advanced-tools">
                <div class="advanced-tool auto" id="toggleAuto"><span class="icon">ðŸ”„</span>Auto Spawn</div>
                <div class="advanced-tool connect" id="toggleConnect"><span class="icon">ðŸ”—</span>Auto Connect</div>
                <div class="advanced-tool attract" id="toggleAttract"><span class="icon">ðŸ§²</span>Attract Mode</div>
                <div class="advanced-tool reset" id="resetSystem"><span class="icon">ðŸ”„</span>Reset</div>
            </div>
        </div>
        
        <div class="panel-content" id="statistics-panel">
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-value rift" id="riftCount">0</div><div class="stat-label">Reality Rifts</div></div>
                <div class="stat-card"><div class="stat-value eruption" id="eruptionCount">0</div><div class="stat-label">Dream Eruptions</div></div>
                <div class="stat-card"><div class="stat-value nexus" id="nexusCount">0</div><div class="stat-label">Sync Nexuses</div></div>
                <div class="stat-card"><div class="stat-value pulse" id="pulseCount">0</div><div class="stat-label">Consciousness Pulses</div></div>
                <div class="stat-card"><div class="stat-value total" id="totalCount">0</div><div class="stat-label">Total Glitches</div></div>
                <div class="stat-card"><div class="stat-value intensity" id="chaosLevel">0%</div><div class="stat-label">Chaos Level</div></div>
            </div>
        </div>
        
        <div class="panel-content" id="logs-panel">
            <div class="log-container" id="logContainer">
                <div class="log-entry"><span class="log-time">00:00:00</span><span class="log-info">System initialized</span></div>
            </div>
        </div>

        <div class="panel-content" id="agents-panel">
            <div class="log-container" id="agentContainer"></div>
        </div>
    </div>

    <div class="quick-actions">
        <div class="quick-action quick-rift" id="quickRift" title="Spawn Rift">âš¡</div>
        <div class="quick-action quick-eruption" id="quickEruption" title="Spawn Eruption">ðŸŒ‹</div>
        <div class="quick-action quick-nexus" id="quickNexus" title="Spawn Nexus">ðŸ”„</div>
        <div class="quick-action quick-pulse" id="quickPulse" title="Spawn Pulse">ðŸ’«</div>
        <div class="quick-action quick-auto" id="quickAuto" title="Toggle Auto Spawn">ðŸ”„</div>
    </div>

    <script>
        // Vector2 helper class
        class Vector2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
            subtract(v) { return new Vector2(this.x - v.x, this.y - v.y); }
            multiply(scalar) { return new Vector2(this.x * scalar, this.y * scalar); }
            distance(v) { return Math.hypot(this.x - v.x, this.y - v.y); }
            magnitude() { return Math.hypot(this.x, this.y); }
            normalize() { const mag = this.magnitude(); return mag === 0 ? new Vector2() : new Vector2(this.x / mag, this.y / mag); }
        }

        // Noise function
        function createNoise2D() {
            return (x, y) => {
                const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                return (n - Math.floor(n)) * 2 - 1;
            };
        }

        // Glitch class with narrative influence
        class Glitch {
            constructor(type, x, y, narrativeContext = {}) {
                this.pos = new Vector2(x, y);
                this.velocity = new Vector2((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4);
                this.type = type;
                this.radius = 20 + Math.random() * 30;
                this.intensity = Math.random() * 0.5 + 0.5;
                this.life = 100 + Math.random() * 200;
                this.color = { rift: '--secondary', eruption: '--quaternary', nexus: '--tertiary', pulse: '--primary' }[type];
                this.particles = [];
                this.maxParticles = 5 + Math.floor(this.intensity * 10);
                this.narrativeContext = narrativeContext;
                this.spawnTime = world.time;
                this.spawnParticles();
            }

            spawnParticles() {
                for (let i = 0; i < this.maxParticles; i++) {
                    this.particles.push({
                        pos: new Vector2(this.pos.x, this.pos.y),
                        velocity: new Vector2((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 3),
                        life: 20 + Math.random() * 40,
                        size: 2 + Math.random() * 3,
                    });
                }
            }

            update(noise) {
                this.pos = this.pos.add(this.velocity.multiply(1 + noise(this.pos.x * 0.01, this.pos.y * 0.01)));
                this.velocity = this.velocity.add(new Vector2(
                    noise(this.life + this.pos.x * 0.01, this.life + this.pos.y * 0.01) * 0.5,
                    noise(this.life + this.pos.y * 0.01, this.life + this.pos.x * 0.01) * 0.5
                ));
                this.life--;
                if (this.pos.x < 0 || this.pos.x > canvas.width) this.velocity.x *= -1;
                if (this.pos.y < 0 || this.pos.y > canvas.height) this.velocity.y *= -1;

                this.particles.forEach(p => {
                    p.pos = p.pos.add(p.velocity);
                    p.life--;
                    p.velocity = p.velocity.multiply(0.98);
                });
                this.particles = this.particles.filter(p => p.life > 0);
                if (this.particles.length < this.maxParticles && Math.random() < 0.1) this.spawnParticles();
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius * this.intensity, 0, Math.PI * 2);
                ctx.fillStyle = `var(${this.color}${Math.floor(this.life / 3).toString(16)})`;
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = `var(${this.color})`;
                ctx.stroke();

                this.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.pos.x, p.pos.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = `var(${this.color}${Math.floor(p.life * 2).toString(16)})`;
                    ctx.fill();
                });
            }
        }

        // HESMS Memory System with Spatial-Temporal Patterns
        class EnhancedMemory {
            constructor() {
                this.memoryId = new Map();
                this.shortTermCapacity = new Map();
                this.shortTermIds = new Map();
                this.shortTermTypes = new Map();
                this.shortTermPositionsX = new Map();
                this.shortTermPositionsY = new Map();
                this.shortTermTimestamps = new Map();
                this.shortTermImportance = new Map();
                this.shortTermFidelity = new Map();
                this.globalFidelity = new Map();
                this.semanticPatterns = new Map();
                this.temporalDrift = new Map();
                this.crossRealityKnowledge = new Map();
            }
        }

        class MemoryManager {
            constructor(world) {
                this.world = world;
                this.memory = new EnhancedMemory();
            }

            initializeAgent(agent) {
                this.memory.memoryId.set(agent, agent);
                this.memory.shortTermCapacity.set(agent, 10);
                this.memory.globalFidelity.set(agent, 1.0);
                this.memory.semanticPatterns.set(agent, []);
                this.memory.temporalDrift.set(agent, { past: [], present: [], future: [] });
                this.memory.crossRealityKnowledge.set(agent, { realities: new Map(), currentReality: 'default_void', profiles: new Map() });
                for (let i = 0; i < 10; i++) {
                    const key = `${agent}-${i}`;
                    this.memory.shortTermIds.set(key, 0);
                    this.memory.shortTermTypes.set(key, 0);
                    this.memory.shortTermPositionsX.set(key, 0);
                    this.memory.shortTermPositionsY.set(key, 0);
                    this.memory.shortTermTimestamps.set(key, 0);
                    this.memory.shortTermImportance.set(key, 0);
                    this.memory.shortTermFidelity.set(key, 0);
                }
            }

            recordEpisodicMemory(agent, memory) {
                const capacity = this.memory.shortTermCapacity.get(agent);
                let oldestIndex = 0;
                let oldestTimestamp = this.memory.shortTermTimestamps.get(`${agent}-0`);

                for (let i = 1; i < capacity; i++) {
                    const timestamp = this.memory.shortTermTimestamps.get(`${agent}-${i}`);
                    if (timestamp < oldestTimestamp) {
                        oldestIndex = i;
                        oldestTimestamp = timestamp;
                    }
                }

                const key = `${agent}-${oldestIndex}`;
                this.memory.shortTermIds.set(key, memory.entityId);
                this.memory.shortTermTypes.set(key, memory.entityType);
                this.memory.shortTermPositionsX.set(key, memory.position.x);
                this.memory.shortTermPositionsY.set(key, memory.position.y);
                this.memory.shortTermTimestamps.set(key, this.world.time);
                this.memory.shortTermImportance.set(key, memory.importance);
                this.memory.shortTermFidelity.set(key, 1.0);

                const drift = this.memory.temporalDrift.get(agent);
                drift.present.push({ ...memory, timestamp: this.world.time });
                if (drift.present.length > 5) drift.past.push(drift.present.shift());
                if (drift.past.length > 10) drift.past.shift();

                const reality = this.memory.crossRealityKnowledge.get(agent);
                if (!reality.realities.has(reality.currentReality)) reality.realities.set(reality.currentReality, []);
                reality.realities.get(reality.currentReality).push(memory);

                this.updateRealityProfile(agent, memory);
            }

            updateRealityProfile(agent, memory) {
                const reality = this.memory.crossRealityKnowledge.get(agent);
                const profile = reality.profiles.get(reality.currentReality) || { spawnRates: {}, avgIntensity: 0, count: 0 };
                profile.spawnRates[memory.entityType] = (profile.spawnRates[memory.entityType] || 0) + 1;
                profile.avgIntensity = (profile.avgIntensity * profile.count + memory.importance) / (profile.count + 1);
                profile.count++;
                reality.profiles.set(reality.currentReality, profile);
            }

            consolidateSemanticMemory(agent) {
                const capacity = this.memory.shortTermCapacity.get(agent);
                const patterns = this.memory.semanticPatterns.get(agent);
                const currentTime = this.world.time;

                const recentMemories = [];
                for (let i = 0; i < capacity; i++) {
                    const key = `${agent}-${i}`;
                    const timestamp = this.memory.shortTermTimestamps.get(key);
                    if (timestamp > 0 && currentTime - timestamp < 500) {
                        recentMemories.push({
                            type: this.memory.shortTermTypes.get(key),
                            position: {
                                x: this.memory.shortTermPositionsX.get(key),
                                y: this.memory.shortTermPositionsY.get(key)
                            },
                            importance: this.memory.shortTermImportance.get(key),
                            fidelity: this.memory.shortTermFidelity.get(key),
                            timestamp
                        });
                    }
                }

                const clusters = {};
                recentMemories.forEach(mem => {
                    const clusterKey = `${Math.floor(mem.position.x / 50)}-${Math.floor(mem.position.y / 50)}`;
                    if (!clusters[clusterKey]) clusters[clusterKey] = { types: {}, positions: [], count: 0, durations: [] };
                    clusters[clusterKey].types[mem.type] = (clusters[clusterKey].types[mem.type] || 0) + mem.importance * mem.fidelity;
                    clusters[clusterKey].positions.push(mem.position);
                    clusters[clusterKey].count++;
                    clusters[clusterKey].durations.push(currentTime - mem.timestamp);
                });

                Object.entries(clusters).forEach(([key, cluster]) => {
                    if (cluster.count >= 3) {
                        const dominantType = Object.keys(cluster.types).reduce((a, b) => cluster.types[a] > cluster.types[b] ? a : b, 0);
                        const avgPos = cluster.positions.reduce((acc, pos) => ({ x: acc.x + pos.x, y: acc.y + pos.y }), { x: 0, y: 0 });
                        avgPos.x /= cluster.positions.length;
                        avgPos.y /= cluster.positions.length;
                        const avgDuration = cluster.durations.reduce((sum, d) => sum + d, 0) / cluster.durations.length;
                        patterns.push({
                            type: dominantType,
                            confidence: Math.min(1, cluster.types[dominantType] / 5),
                            description: `${this.typeToName(dominantType)} often near (${avgPos.x.toFixed(0)}, ${avgPos.y.toFixed(0)}), lasting ~${avgDuration.toFixed(0)} ticks`,
                            position: avgPos,
                            avgDuration,
                            timestamp: currentTime
                        });
                        logMessage(`Agent ${agent} consolidates: ${patterns[patterns.length - 1].description}`, 'success');
                    }
                });

                this.reconstructPastMemories(agent);
            }

            typeToName(type) {
                return { 0: 'Stable entities', 1: 'Resources', 2: 'Hazards', 99: 'Dreams' }[type] || 'Unknown';
            }

            reconstructPastMemories(agent) {
                const drift = this.memory.temporalDrift.get(agent);
                const patterns = this.memory.semanticPatterns.get(agent);
                drift.past.forEach((mem, i) => {
                    const nearestPattern = patterns.find(p => p.position && mem.position.distance(p.position) < 50);
                    if (nearestPattern && Math.random() < 0.3) {
                        const reinterpretation = `That ${this.typeToName(mem.entityType)} at (${mem.position.x.toFixed(0)}, ${mem.position.y.toFixed(0)}) was tied to ${nearestPattern.description.split('often')[0]}`;
                        logMessage(`Agent ${agent} reinterprets: ${reinterpretation}`, 'pulse');
                        mem.importance = Math.min(1, mem.importance + 0.1);
                        drift.past[i] = mem;
                    }
                });
            }

            projectFuture(agent, scenario) {
                const drift = this.memory.temporalDrift.get(agent);
                const patterns = this.memory.semanticPatterns.get(agent);
                const nearestPattern = patterns.find(p => p.position && scenario.position.distance(p.position) < 50);
                if (nearestPattern) {
                    const futureEvent = {
                        entityType: nearestPattern.type,
                        position: scenario.position,
                        importance: nearestPattern.confidence * 0.8,
                        timestamp: this.world.time + Math.floor(nearestPattern.avgDuration),
                        prediction: true
                    };
                    drift.future.push(futureEvent);
                    if (drift.future.length > 5) drift.future.shift();
                    logMessage(`Agent ${agent} predicts: ${this.typeToName(nearestPattern.type)} near (${scenario.position.x.toFixed(0)}, ${scenario.position.y.toFixed(0)}) in ${Math.floor(nearestPattern.avgDuration)} ticks`, 'info');
                }
            }

            getSemanticMemory(agent) {
                return {
                    patterns: this.memory.semanticPatterns.get(agent),
                    addPattern: (pattern) => this.memory.semanticPatterns.get(agent).push(pattern)
                };
            }

            getTemporalDrift(agent) { return this.memory.temporalDrift.get(agent); }
            getCrossRealityKnowledge(agent) { return this.memory.crossRealityKnowledge.get(agent); }

            shiftReality(agent, newReality) {
                const reality = this.memory.crossRealityKnowledge.get(agent);
                reality.currentReality = newReality;
                logMessage(`Agent ${agent} shifts to reality: ${newReality}`, 'warning');
            }

            transferKnowledge(agent, fromReality, toReality) {
                const reality = this.memory.crossRealityKnowledge.get(agent);
                const fromProfile = reality.profiles.get(fromReality);
                const toProfile = reality.profiles.get(toReality) || { spawnRates: {}, avgIntensity: 0, count: 0 };
                if (fromProfile && fromProfile.count > 5) {
                    const similarity = this.calculateRealitySimilarity(fromProfile, toProfile);
                    if (similarity > 0.5) {
                        const patterns = this.memory.semanticPatterns.get(agent);
                        patterns.forEach(p => {
                            if (p.confidence > 0.7) {
                                const transferredPattern = { ...p, confidence: p.confidence * similarity, timestamp: this.world.time };
                                patterns.push(transferredPattern);
                                logMessage(`Agent ${agent} transfers: ${p.description} to ${toReality} (Similarity: ${similarity.toFixed(2)})`, 'nexus');
                            }
                        });
                    }
                }
            }

            calculateRealitySimilarity(profileA, profileB) {
                const typesA = Object.keys(profileA.spawnRates).map(Number);
                const typesB = Object.keys(profileB.spawnRates).map(Number);
                const sharedTypes = typesA.filter(t => typesB.includes(t)).length;
                const totalTypes = new Set([...typesA, ...typesB]).size;
                const typeSimilarity = sharedTypes / totalTypes || 0;
                const intensityDiff = Math.abs(profileA.avgIntensity - profileB.avgIntensity);
                return Math.max(0, typeSimilarity - intensityDiff / 2);
            }
        }

        // HESMS Imagination System
        class Imagination {
            constructor(agent, memoryManager) {
                this.agent = agent;
                this.memoryManager = memoryManager;
                this.predictions = [];
            }

            simulateScenario(targetPos, action) {
                const semantic = this.memoryManager.getSemanticMemory(this.agent).patterns;
                const pos = Position.get(this.agent);
                const distance = pos.distance(targetPos);

                let risk = 0;
                let reward = 0;
                semantic.forEach(p => {
                    if (p.position && p.position.distance(targetPos) < 50) {
                        if (p.type == 2) risk += p.confidence * 0.5;
                        if (p.type == 1) reward += p.confidence * 0.5;
                    }
                });

                glitches.forEach(g => {
                    if (g.pos.distance(targetPos) < 50) {
                        if (g.type === 'rift' || g.type === 'pulse') risk += g.intensity * 0.3;
                        if (g.type === 'eruption' || g.type === 'nexus') reward += g.intensity * 0.3;
                    }
                });

                const outcome = {
                    action,
                    target: targetPos,
                    risk: Math.min(1, risk),
                    reward: Math.min(1, reward),
                    probability: Math.random() * 0.5 + 0.5,
                    timestamp: world.time
                };
                this.predictions.push(outcome);
                if (this.predictions.length > 5) this.predictions.shift();

                logMessage(`Agent ${this.agent} imagines: ${action} at (${targetPos.x.toFixed(0)}, ${targetPos.y.toFixed(0)}) - Risk: ${(outcome.risk * 100).toFixed(0)}%, Reward: ${(outcome.reward * 100).toFixed(0)}%`, 'pulse');
                this.memoryManager.projectFuture(this.agent, { position: targetPos });
                return outcome;
            }

            getBestAction(options) {
                const outcomes = options.map(opt => this.simulateScenario(opt.target, opt.action));
                return outcomes.reduce((best, curr) => (curr.reward - curr.risk) > (best.reward - best.risk) ? curr : best, outcomes[0]);
            }
        }

        // HESMS Narrative Construction
        class NarrativeConstruction {
            constructor(agent, memoryManager) {
                this.agent = agent;
                this.memoryManager = memoryManager;
                this.chapters = [];
                this.characters = new Map();
            }

            updateNarrative() {
                const semantic = this.memoryManager.getSemanticMemory(this.agent).patterns;
                const drift = this.memoryManager.getTemporalDrift(this.agent);
                const reality = this.memoryManager.getCrossRealityKnowledge(this.agent).currentReality;

                if (semantic.length > 0 && Math.random() < 0.1) {
                    const pattern = semantic[semantic.length - 1];
                    const character = this.assignCharacter(pattern);
                    const chapter = {
                        title: `${character.role} at (${pattern.position.x.toFixed(0)}, ${pattern.position.y.toFixed(0)})`,
                        description: `${character.name}, the ${character.role}, shapes my path: ${pattern.description}`,
                        reality,
                        timestamp: world.time,
                        emotionalTone: 50 + (Math.random() * 30 - 15)
                    };
                    this.chapters.push(chapter);
                    logMessage(`Agent ${this.agent} narrates: ${chapter.description}`, 'eruption');

                    if (this.chapters.length > 5) this.chapters.shift();
                }
            }

            assignCharacter(pattern) {
                const key = `${pattern.type}-${pattern.position.x.toFixed(0)}-${pattern.position.y.toFixed(0)}`;
                if (!this.characters.has(key)) {
                    const roles = { 0: 'Guide', 1: 'Ally', 2: 'Antagonist', 99: 'Mystery' };
                    const names = ['Zorak', 'Lira', 'Kael', 'Vex', 'Nyx'];
                    this.characters.set(key, {
                        name: names[Math.floor(Math.random() * names.length)],
                        role: roles[pattern.type] || 'Unknown',
                        type: pattern.type,
                        position: pattern.position
                    });
                }
                return this.characters.get(key);
            }

            getIdentity() {
                if (this.chapters.length === 0) return `Agent ${this.agent}, a blank slate in the nexus`;
                const keyEvents = this.chapters.map(c => c.title.split(' at ')[0]).join(', ');
                return `Agent ${this.agent}, ${this.chapters.length > 2 ? 'chronicler' : 'witness'} of ${keyEvents}`;
            }

            influenceBehavior() {
                const latestChapter = this.chapters[this.chapters.length - 1];
                if (latestChapter && latestChapter.role === 'Antagonist') {
                    return { avoid: latestChapter.position };
                }
                return null;
            }
        }

        // HESMS Consciousness with Self-Reflection and Narratives
        class DreamState {
            constructor(agent, memoryManager) {
                this.agent = agent;
                this.memoryManager = memoryManager;
                this.dreamMemories = [];
                this.narrativeFragments = [];
                this.isActive = false;
                this.intensity = 0;
                this.duration = 0;
            }

            activate(intensity = 0.6) {
                this.isActive = true;
                this.intensity = Math.min(1, Math.max(0, intensity));
                this.duration = 0;
                this.dreamMemories = [];
                this.narrativeFragments = [];
                this.gatherSignificantMemories();
                logMessage(`Agent ${this.agent} enters dream state with intensity ${this.intensity.toFixed(2)}`, 'info');
            }

            deactivate() {
                this.isActive = false;
                this.consolidateDreamExperience();
                logMessage(`Agent ${this.agent} exits dream state`, 'info');
            }

            gatherSignificantMemories() {
                const capacity = this.memoryManager.memory.shortTermCapacity.get(this.agent);
                const currentTime = this.memoryManager.world.time;
                const shortTermMemories = [];

                for (let i = 0; i < capacity; i++) {
                    const key = `${this.agent}-${i}`;
                    const importance = this.memoryManager.memory.shortTermImportance.get(key);
                    const timestamp = this.memoryManager.memory.shortTermTimestamps.get(key);
                    if (importance > 0.6 && timestamp > 0 && currentTime - timestamp < 500) {
                        shortTermMemories.push({
                            entityId: this.memoryManager.memory.shortTermIds.get(key),
                            entityType: this.memoryManager.memory.shortTermTypes.get(key),
                            position: {
                                x: this.memoryManager.memory.shortTermPositionsX.get(key),
                                y: this.memoryManager.memory.shortTermPositionsY.get(key)
                            },
                            timestamp,
                            importance,
                            fidelity: this.memoryManager.memory.shortTermFidelity.get(key)
                        });
                    }
                }

                this.dreamMemories = shortTermMemories.sort((a, b) => b.importance - a.importance);
            }

            update() {
                if (!this.isActive) return;
                this.duration++;

                if (this.duration % 20 === 0 && this.dreamMemories.length > 0) {
                    const fragment = this.generateNarrativeFragment();
                    this.narrativeFragments.push(fragment);
                    logMessage(`Agent ${this.agent} dreams: ${fragment.description}`, 'eruption');
                    spawnGlitch('eruption', Position.get(this.agent).x, Position.get(this.agent).y, { agentId: this.agent, memoryType: 'dream' });
                }

                if (this.duration >= 200 || Math.random() < 0.02) {
                    this.deactivate();
                }
            }

            generateNarrativeFragment() {
                const memory = this.dreamMemories[Math.floor(Math.random() * this.dreamMemories.length)] || { entityType: 99 };
                const themes = {
                    0: { theme: 'stability', description: 'I drift through a calm void, untouched by chaos.' },
                    1: { theme: 'resource', description: 'Golden threads pull me toward a shimmering core.' },
                    2: { theme: 'hazard', description: 'Fractures tear at my edges, a scream in the dark.' },
                    99: { theme: 'unknown', description: 'Shadows whisper truths I cannot grasp.' }
                };
                const { theme, description } = themes[memory.entityType] || themes[99];
                return {
                    theme,
                    description,
                    emotionalTone: 50 + (Math.random() * 30 - 15),
                    timestamp: this.memoryManager.world.time,
                    duration: 30 + Math.random() * 50
                };
            }

            consolidateDreamExperience() {
                if (this.narrativeFragments.length === 0) return;

                const dreamMemory = {
                    entityId: this.agent,
                    entityType: 99,
                    position: Position.get(this.agent),
                    importance: 0.7 + (this.intensity * 0.3),
                    context: { dreamState: true, fragments: this.narrativeFragments.length }
                };
                this.memoryManager.recordEpisodicMemory(this.agent, dreamMemory);
                ConsciousnessState.get(this.agent).selfAwarenessLevel = Math.min(1, ConsciousnessState.get(this.agent).selfAwarenessLevel + 0.05);
                this.memoryManager.consolidateSemanticMemory(this.agent);
            }
        }

        const ConsciousnessState = new Map();

        class ConsciousnessManager {
            constructor(memoryManager) {
                this.memoryManager = memoryManager;
                this.dreamStates = new Map();
                this.imaginations = new Map();
                this.narratives = new Map();
                this.initialized = false;
            }

            initialize() {
                if (this.initialized) return;
                world.entities.forEach(agent => {
                    if (CognitiveState.has(agent)) {
                        ConsciousnessState.set(agent, {
                            dreamCyclePhase: Math.random(),
                            dreamingActive: 0,
                            selfAwarenessLevel: 0.1,
                            integrationIndex: 0.0,
                            reflectionCooldown: 0
                        });
                        this.dreamStates.set(agent, new DreamState(agent, this.memoryManager));
                        this.imaginations.set(agent, new Imagination(agent, this.memoryManager));
                        this.narratives.set(agent, new NarrativeConstruction(agent, this.memoryManager));
                    }
                });
                this.initialized = true;
            }

            updateConsciousness(agent) {
                const state = ConsciousnessState.get(agent);
                if (!state) return;

                const dreamState = this.dreamStates.get(agent);
                state.dreamCyclePhase = (state.dreamCyclePhase + 0.00167) % 1;

                if (!state.dreamingActive) {
                    if (state.dreamCyclePhase > 0.85 && Math.random() < 0.1) {
                        state.dreamingActive = 1;
                        dreamState.activate(0.6 + Math.random() * 0.4);
                    }
                } else {
                    dreamState.update();
                    if (!dreamState.isActive) state.dreamingActive = 0;
                }

                state.integrationIndex = Math.min(1, state.integrationIndex + 0.001);

                if (state.reflectionCooldown <= 0 && Math.random() < 0.05) {
                    this.reflect(agent);
                    state.reflectionCooldown = 100;
                } else if (state.reflectionCooldown > 0) {
                    state.reflectionCooldown--;
                }

                this.narratives.get(agent).updateNarrative();
            }

            reflect(agent) {
                const state = ConsciousnessState.get(agent);
                const semantic = this.memoryManager.getSemanticMemory(agent).patterns;
                const drift = this.memoryManager.getTemporalDrift(agent);
                const reality = this.memoryManager.getCrossRealityKnowledge(agent);

                if (semantic.length > 0) {
                    const pattern = semantic[semantic.length - 1];
                    const reflection = `I am ${state.selfAwarenessLevel > 0.5 ? 'more than code' : 'a fragment'}â€”${pattern.description}`;
                    logMessage(`Agent ${agent} reflects: ${reflection}`, 'nexus');

                    if (pattern.type == 2) {
                        CognitiveState.get(agent).adaptability = Math.max(40, CognitiveState.get(agent).adaptability - 10);
                        SensoryData.get(agent).visionRange = Math.min(150, SensoryData.get(agent).visionRange + 20);
                        logMessage(`Agent ${agent} becomes more cautious after reflecting on hazards`, 'warning');
                    } else if (pattern.type == 1) {
                        CognitiveState.get(agent).curiosity = Math.min(100, CognitiveState.get(agent).curiosity + 10);
                        logMessage(`Agent ${agent} grows more curious after reflecting on resources`, 'success');
                    }
                }

                if (drift.past.length > 0 && Math.random() < 0.3) {
                    const pastMemory = drift.past[Math.floor(Math.random() * drift.past.length)];
                    logMessage(`Agent ${agent} recalls: A ${pastMemory.entityType === 2 ? 'hazard' : 'moment'} at (${pastMemory.position.x.toFixed(0)}, ${pastMemory.position.y.toFixed(0)}) lingers.`, 'pulse');
                }

                if (reality.realities.size > 1 && Math.random() < 0.2) {
                    const otherReality = Array.from(reality.realities.keys()).find(r => r !== reality.currentReality);
                    const knowledge = reality.realities.get(otherReality)[0];
                    logMessage(`Agent ${agent} senses cross-reality: In ${otherReality}, I knew ${knowledge.entityType === 2 ? 'danger' : 'calm'}.`, 'rift');
                    this.memoryManager.transferKnowledge(agent, otherReality, reality.currentReality);
                }
            }

            getConsciousnessReport(agent) {
                const state = ConsciousnessState.get(agent);
                if (!state) return null;
                return {
                    agent,
                    selfAwareness: state.selfAwarenessLevel,
                    integrationIndex: state.integrationIndex,
                    isDreaming: state.dreamingActive > 0,
                    dreamPhase: state.dreamCyclePhase
                };
            }
        }

        // ArgOS Framework Integration
        const Position = new Map();
        const SensoryData = new Map();
        const Goals = new Map();
        const CognitiveState = new Map();

        const world = {
            entities: [],
            time: 0,
            lastTime: 0,
            systems: [],
            realityWave: { active: false, timer: 500, realities: [
                { name: 'default_void', tint: 'rgba(10, 10, 26, 1)' },
                { name: 'glitch_forest', tint: 'rgba(0, 50, 0, 0.8)' },
                { name: 'digital_realm', tint: 'rgba(0, 0, 50, 0.8)' }
            ]}
        };

        function addEntity() {
            const entity = world.entities.length;
            world.entities.push(entity);
            return entity;
        }

        function createDefaultSystems() {
            return [
                (world) => {
                    world.lastTime = world.time;
                    world.time++;
                    if (world.realityWave.timer-- <= 0) {
                        world.realityWave.active = !world.realityWave.active;
                        world.realityWave.timer = 500;
                        if (world.realityWave.active) {
                            const newReality = world.realityWave.realities[Math.floor(Math.random() * world.realityWave.realities.length)];
                            world.entities.forEach(agent => {
                                if (CognitiveState.has(agent)) memoryManager.shiftReality(agent, newReality.name);
                            });
                        }
                    }
                    return world;
                },
                (world) => {
                    world.entities.forEach(agent => {
                        if (!SensoryData.has(agent)) return;
                        const pos = Position.get(agent);
                        const range = SensoryData.get(agent).visionRange || 100;

                        const detected = [];
                        glitches.forEach((glitch, index) => {
                            const distance = pos.distance(glitch.pos);
                            if (distance <= range) {
                                detected.push({ entityId: index, type: glitch.type, distance });
                            }
                        });

                        detected.sort((a, b) => a.distance - b.distance);
                        SensoryData.get(agent).entitiesDetected = detected.slice(0, 10);
                    });
                    return world;
                },
                (world) => {
                    world.entities.forEach(agent => {
                        if (!Goals.has(agent) || !SensoryData.has(agent)) return;
                        if (Goals.get(agent).completionPercentage >= 95) {
                            let goalType = 0;
                            let targetX = Position.get(agent).x + (Math.random() * 40 - 20);
                            let targetY = Position.get(agent).y + (Math.random() * 40 - 20);

                            const detected = SensoryData.get(agent).entitiesDetected;
                            const semantic = memoryManager.getSemanticMemory(agent).patterns;
                            const narrative = consciousnessManager.narratives.get(agent).influenceBehavior();
                            const imagination = consciousnessManager.imaginations.get(agent);

                            if (narrative && narrative.avoid) {
                                goalType = 2;
                                const dx = Position.get(agent).x - narrative.avoid.x;
                                const dy = Position.get(agent).y - narrative.avoid.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0) {
                                    targetX = Position.get(agent).x + (dx / dist) * 100;
                                    targetY = Position.get(agent).y + (dy / dist) * 100;
                                }
                            } else {
                                const hazardCluster = semantic.find(p => p.type == 2 && p.position);
                                const resourceCluster = semantic.find(p => p.type == 1 && p.position);

                                const options = [];
                                if (hazardCluster) options.push({ action: 'avoid', target: hazardCluster.position });
                                if (resourceCluster) options.push({ action: 'approach', target: resourceCluster.position });
                                detected.forEach(d => {
                                    const glitch = glitches[d.entityId];
                                    options.push({ action: d.type === 'rift' || d.type === 'pulse' ? 'avoid' : 'approach', target: glitch.pos });
                                });

                                if (options.length > 0) {
                                    const bestAction = imagination.getBestAction(options);
                                    goalType = bestAction.action === 'avoid' ? 2 : 1;
                                    targetX = bestAction.target.x;
                                    targetY = bestAction.target.y;
                                }
                            }

                            Goals.set(agent, { primaryType: goalType, targetX, targetY, completionPercentage: 0 });
                        }
                    });
                    return world;
                },
                (world) => {
                    world.entities.forEach(agent => {
                        if (!Position.has(agent) || !Goals.has(agent)) return;
                        const pos = Position.get(agent);
                        const targetX = Goals.get(agent).targetX;
                        const targetY = Goals.get(agent).targetY;

                        if (targetX === 0 && targetY === 0) return;

                        const dx = targetX - pos.x;
                        const dy = targetY - pos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 1) {
                            const moveSpeed = CognitiveState.get(agent).adaptability * 0.001;
                            pos.x += (dx / distance) * moveSpeed;
                            pos.y += (dy / distance) * moveSpeed;
                            Goals.get(agent).completionPercentage += 0.1;
                        } else {
                            Goals.get(agent).completionPercentage = 100;
                        }
                    });
                    return world;
                }
            ];
        }

        // System state
        const canvas = document.getElementById('glitchCanvas');
        const ctx = canvas.getContext('2d');
        const logContainer = document.getElementById('logContainer');
        const agentContainer = document.getElementById('agentContainer');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const noise = createNoise2D();
        let time = 0;
        const glitches = [];
        let autoSpawn = false;
        let autoConnect = false;
        let attractMode = false;

        const stats = { rift: 0, eruption: 0, nexus: 0, pulse: 0, total: 0, chaosLevel: 0 };

        const memoryManager = new MemoryManager(world);
        const consciousnessManager = new ConsciousnessManager(memoryManager);

        for (let i = 0; i < 3; i++) {
            const agent = addEntity();
            Position.set(agent, new Vector2(Math.random() * canvas.width, Math.random() * canvas.height));
            SensoryData.set(agent, { visionRange: 100, entitiesDetected: [] });
            Goals.set(agent, { primaryType: 0, targetX: 0, targetY: 0, completionPercentage: 0 });
            CognitiveState.set(agent, { emotionalState: 50, adaptability: 60 + Math.random() * 20, curiosity: 70, socialAffinity: 30 + Math.random() * 30 });
            memoryManager.initializeAgent(agent);
        }

        world.systems = createDefaultSystems();
        consciousnessManager.initialize();

        function updateSystemTime() {
            const now = new Date();
            document.getElementById('systemTime').textContent = now.toTimeString().split(' ')[0];
        }
        setInterval(updateSystemTime, 1000);

        function logMessage(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry`;
            const time = new Date().toTimeString().split(' ')[0];
            entry.innerHTML = `<span class="log-time">${time}</span><span class="log-${type}">${message}</span>`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            if (logContainer.children.length > 20) logContainer.removeChild(logContainer.lastChild);
        }

        function updateAgentPanel() {
            agentContainer.innerHTML = '';
            world.entities.forEach(agent => {
                if (!CognitiveState.has(agent)) return;
                const report = consciousnessManager.getConsciousnessReport(agent);
                if (!report) return;
                const semantic = memoryManager.getSemanticMemory(agent).patterns;
                const drift = memoryManager.getTemporalDrift(agent);
                const reality = memoryManager.getCrossRealityKnowledge(agent);
                const narrative = consciousnessManager.narratives.get(agent);
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.innerHTML = `
                    <span class="log-time">Agent ${agent}</span>
                    <span class="log-info">
                        Awareness: ${(report.selfAwareness * 100).toFixed(1)}% | 
                        Integration: ${(report.integrationIndex * 100).toFixed(1)}% | 
                        ${report.isDreaming ? 'Dreaming' : 'Awake'} | 
                        Reality: ${reality.currentReality}
                    </span>
                    <div class="agent-info">
                        Patterns: ${semantic.length} | Memories: ${drift.present.length + drift.past.length} | 
                        Identity: ${narrative.getIdentity()}
                    </div>`;
                agentContainer.appendChild(entry);
            });
        }
        setInterval(updateAgentPanel, 1000);

        function spawnGlitch(type, x = Math.random() * canvas.width, y = Math.random() * canvas.height, narrativeContext = {}) {
            const glitch = new Glitch(type, x, y, narrativeContext);
            glitches.push(glitch);
            stats[type]++;
            stats.total++;
            logMessage(`Spawned ${type.replace('_', ' ')} at (${Math.floor(x)}, ${Math.floor(y)})`, type);
            updateStats();
        }

        function updateStats() {
            stats.chaosLevel = Math.min(100, (glitches.reduce((sum, g) => sum + g.intensity, 0) / 10) * 100).toFixed(1);
            document.getElementById('riftCount').textContent = stats.rift;
            document.getElementById('eruptionCount').textContent = stats.eruption;
            document.getElementById('nexusCount').textContent = stats.nexus;
            document.getElementById('pulseCount').textContent = stats.pulse;
            document.getElementById('totalCount').textContent = stats.total;
            document.getElementById('chaosLevel').textContent = `${stats.chaosLevel}%`;
        }

        const controlToggle = document.getElementById('controlToggle');
        const controlPanel = document.getElementById('controlPanel');
        controlToggle.addEventListener('click', () => {
            controlToggle.classList.toggle('active');
            controlPanel.classList.toggle('active');
        });

        const tabs = document.querySelectorAll('.panel-tab');
        const panels = document.querySelectorAll('.panel-content');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                panels.forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.panel}-panel`).classList.add('active');
            });
        });

        document.getElementById('spawnRift').addEventListener('click', () => spawnGlitch('rift'));
        document.getElementById('spawnEruption').addEventListener('click', () => spawnGlitch('eruption'));
        document.getElementById('spawnNexus').addEventListener('click', () => spawnGlitch('nexus'));
        document.getElementById('spawnPulse').addEventListener('click', () => spawnGlitch('pulse'));

        const toggleAutoBtn = document.getElementById('toggleAuto');
        toggleAutoBtn.addEventListener('click', () => {
            autoSpawn = !autoSpawn;
            toggleAutoBtn.classList.toggle('active-tool');
            logMessage(`Auto Spawn ${autoSpawn ? 'enabled' : 'disabled'}`, 'success');
        });

        const toggleConnectBtn = document.getElementById('toggleConnect');
        toggleConnectBtn.addEventListener('click', () => {
            autoConnect = !autoConnect;
            toggleConnectBtn.classList.toggle('active-tool');
            logMessage(`Auto Connect ${autoConnect ? 'enabled' : 'disabled'}`, 'info');
        });

        const toggleAttractBtn = document.getElementById('toggleAttract');
        toggleAttractBtn.addEventListener('click', () => {
            attractMode = !attractMode;
            toggleAttractBtn.classList.toggle('active-tool');
            logMessage(`Attract Mode ${attractMode ? 'enabled' : 'disabled'}`, 'warning');
        });

        document.getElementById('resetSystem').addEventListener('click', () => {
            glitches.length = 0;
            stats.rift = stats.eruption = stats.nexus = stats.pulse = stats.total = 0;
            stats.chaosLevel = 0;
            autoSpawn = autoConnect = attractMode = false;
            toggleAutoBtn.classList.remove('active-tool');
            toggleConnectBtn.classList.remove('active-tool');
            toggleAttractBtn.classList.remove('active-tool');
            document.getElementById('quickAuto').classList.remove('active-tool');
            world.entities.forEach(agent => {
                if (Position.has(agent)) {
                    Position.set(agent, new Vector2(Math.random() * canvas.width, Math.random() * canvas.height));
                    Goals.set(agent, { primaryType: 0, targetX: 0, targetY: 0, completionPercentage: 0 });
                    memoryManager.initializeAgent(agent);
                    ConsciousnessState.get(agent).selfAwarenessLevel = 0.1;
                }
            });
            logMessage('System reset', 'danger');
            updateStats();
        });

        document.getElementById('quickRift').addEventListener('click', () => spawnGlitch('rift'));
        document.getElementById('quickEruption').addEventListener('click', () => spawnGlitch('eruption'));
        document.getElementById('quickNexus').addEventListener('click', () => spawnGlitch('nexus'));
        document.getElementById('quickPulse').addEventListener('click', () => spawnGlitch('pulse'));
        const quickAutoBtn = document.getElementById('quickAuto');
        quickAutoBtn.addEventListener('click', () => {
            autoSpawn = !autoSpawn;
            quickAutoBtn.classList.toggle('active-tool');
            logMessage(`Auto Spawn ${autoSpawn ? 'enabled' : 'disabled'}`, 'success');
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const types = ['rift', 'eruption', 'nexus', 'pulse'];
            spawnGlitch(types[Math.floor(Math.random() * types.length)], x, y);
        });

        function animate() {
            const currentReality = world.realityWave.realities.find(r => r.name === memoryManager.getCrossRealityKnowledge(0).currentReality) || world.realityWave.realities[0];
            ctx.fillStyle = world.realityWave.active ? `${currentReality.tint.slice(0, -2)}, 0.5)` : 'rgba(10, 10, 26, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            time += 0.02;

            for (const system of world.systems) {
                system(world);
            }

            world.entities.forEach(agent => {
                if (CognitiveState.has(agent)) {
                    consciousnessManager.updateConsciousness(agent);

                    const detected = SensoryData.get(agent).entitiesDetected;
                    detected.forEach(d => {
                        const glitch = glitches[d.entityId];
                        if (glitch) {
                            memoryManager.recordEpisodicMemory(agent, {
                                entityId: d.entityId,
                                entityType: { rift: 2, eruption: 1, nexus: 1, pulse: 2 }[glitch.type],
                                position: glitch.pos,
                                importance: 0.7 + glitch.intensity * 0.3
                            });
                        }
                    });
                }
            });

            if (autoSpawn && Math.random() < 0.05) {
                spawnGlitch(['rift', 'eruption', 'nexus', 'pulse'][Math.floor(Math.random() * 4)]);
            }

            glitches.forEach((glitch, i) => {
                glitch.update(noise);
                glitch.draw(ctx);

                if (autoConnect) {
                    glitches.forEach((other, j) => {
                        if (i !== j && glitch.pos.distance(other.pos) < 150) {
                            ctx.beginPath();
                            ctx.moveTo(glitch.pos.x, glitch.pos.y);
                            ctx.lineTo(other.pos.x, other.pos.y);
                            ctx.strokeStyle = `var(--tertiary${Math.floor(Math.min(glitch.life, other.life) / 3).toString(16)})`;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    });
                }

                if (attractMode) {
                    glitches.forEach((other, j) => {
                        if (i !== j) {
                            const direction = other.pos.subtract(glitch.pos).normalize();
                            glitch.velocity = glitch.velocity.add(direction.multiply(0.05));
                        }
                    });
                }

                if (glitch.life <= 0) {
                    stats[glitch.type]--;
                    stats.total--;
                    glitches.splice(i, 1);
                    logMessage(`${glitch.type.replace('_', ' ')} faded at (${Math.floor(glitch.pos.x)}, ${Math.floor(glitch.pos.y)})`, glitch.type);
                    updateStats();
                }
            });

            world.entities.forEach(agent => {
                if (!Position.has(agent) || !CognitiveState.has(agent)) return;
                const pos = Position.get(agent);
                const report = consciousnessManager.getConsciousnessReport(agent);
                if (!report) return;
                const narrative = consciousnessManager.narratives.get(agent);

                // Draw agent
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = report.isDreaming ? 'rgba(142, 68, 173, 0.8)' : '#2ecc71';
                ctx.fill();

                // Draw goal direction
                if (Goals.has(agent)) {
                    const targetX = Goals.get(agent).targetX;
                    const targetY = Goals.get(agent).targetY;
                    ctx.strokeStyle = '#2ecc71';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    const dx = targetX - pos.x;
                    const dy = targetY - pos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        const lineLength = Math.min(dist, 15);
                ctx.lineTo(pos.x + (dx / dist) * lineLength, pos.y + (dy / dist) * lineLength);
            }
            ctx.stroke();
        }

        // Integration aura
        const integrationAura = 15 * (0.5 + report.integrationIndex * 0.5);
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, integrationAura, 0, 2 * Math.PI);
        ctx.fillStyle = `rgba(41, 128, 185, ${0.2 * report.integrationIndex})`;
        ctx.fill();

        // Self-awareness nodes
        const awarenessNodes = Math.min(5, Math.floor(report.selfAwareness * 5));
        for (let i = 0; i < awarenessNodes; i++) {
            const angle = (i / awarenessNodes) * 2 * Math.PI + time;
            const nodeX = pos.x + Math.cos(angle) * 10;
            const nodeY = pos.y + Math.sin(angle) * 10;
            ctx.beginPath();
            ctx.arc(nodeX, nodeY, 1 + report.selfAwareness * 2, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(255, 215, 0, 0.7)';
            ctx.fill();
        }

        // Dream state visualization
        if (report.isDreaming) {
            const dreamIntensity = Math.sin(Date.now() / 300) * 0.3 + 0.7;
            const waveCount = 3;
            for (let i = 0; i < waveCount; i++) {
                const wavePhase = (Date.now() / 1000 + i * 0.5) % (Math.PI * 2);
                const waveSize = 5 + i * 3;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, waveSize, 0, 2 * Math.PI);
                ctx.strokeStyle = `rgba(142, 68, 173, ${0.6 * dreamIntensity * (1 - i / waveCount)})`;
                ctx.lineWidth = 1 + Math.sin(wavePhase) * 0.5;
                ctx.stroke();
            }
        }

        // Narrative connections
        narrative.characters.forEach(char => {
            if (char.position.distance(pos) < 100) {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(char.position.x, char.position.y);
                ctx.strokeStyle = 'rgba(255, 69, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        });

        // Thought bubble for reflection/imagination
        if (ConsciousnessState.get(agent).reflectionCooldown > 80) {
            ctx.beginPath();
            ctx.arc(pos.x + 15, pos.y - 15, 8, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pos.x + 12, pos.y - 5, 2, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Future predictions
        const drift = memoryManager.getTemporalDrift(agent);
        drift.future.forEach(f => {
            if (world.time < f.timestamp + 50) {
                ctx.beginPath();
                ctx.arc(f.position.x, f.position.y, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = 'rgba(0, 206, 209, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        });

        // Agent label
        ctx.font = '10px "Roboto Mono"';
        ctx.fillStyle = report.isDreaming ? 'var(--primary)' : 'var(--success)';
        ctx.textAlign = 'center';
        ctx.fillText(`Agent ${agent}`, pos.x, pos.y - 15);
    });

    // Reality shift effect
    if (world.realityWave.active && world.realityWave.timer > 490) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    requestAnimationFrame(animate);
}

// Resize handler
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

// Start the system
animate();
updateSystemTime();
</script>
</body>
</html>
